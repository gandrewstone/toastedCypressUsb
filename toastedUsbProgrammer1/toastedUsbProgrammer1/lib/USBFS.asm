;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USBFS.asm
;;   Version: 1.80, Updated on 2011/9/2 at 9:40:44
;;  Generated by PSoC Designer 5.1.2309
;;
;;  DESCRIPTION: USB Device User Module software implementation file
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "USBFS_macros.inc"
include "USBFS.inc"
IF 0x2 & 0x10000000
PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
; This message will only appear if the USB Setup Wizard has not be run and the descriptors
; and associated data structures have been created.
; After running the USB Setup Wizard, you must also select the Config/Generate Application
; menu item from PSoC Designer in order to generate USB User Module data structures and
; descriptors.
ENDIF
;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
export  USBFS_Start
export _USBFS_Start
export  USBFS_Stop
export _USBFS_Stop
export  USBFS_bCheckActivity
export _USBFS_bCheckActivity
export  USBFS_bGetConfiguration
export _USBFS_bGetConfiguration
export  USBFS_bGetEPState
export _USBFS_bGetEPState
export  USBFS_wGetEPCount
export _USBFS_wGetEPCount
export  USBFS_LoadInEP
export _USBFS_LoadInEP
export  USBFS_LoadInISOCEP
export _USBFS_LoadInISOCEP
export  USBFS_EnableOutEP
export _USBFS_EnableOutEP
export  USBFS_EnableOutISOCEP
export _USBFS_EnableOutISOCEP
export  USBFS_DisableOutEP
export _USBFS_DisableOutEP
export  USBFS_bReadOutEP
export _USBFS_bReadOutEP
export  USBFS_Force
export _USBFS_Force
export  USBFS_bGetEPAckState
export _USBFS_bGetEPAckState
;export USBFS_Suspend
;export _USBFS_Suspend
;export USBFS_Resume
;export _USBFS_Resume
export  USBFS_bRWUEnabled
export _USBFS_bRWUEnabled
export  USBFS_SetPowerStatus
export _USBFS_SetPowerStatus

AREA InterruptRAM (RAM, REL, CON)
;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------

;-----------------------------------------------
;  Variable Allocation
;-----------------------------------------------
;----------------------------------------------------------------------------
; Control Endpoint Data toggle
export USBFS_EPXDataToggle, _USBFS_EPXDataToggle
 _USBFS_EPXDataToggle:
 USBFS_EPXDataToggle:                   BLK   1


export USBFS_APITemp
 USBFS_APITemp:                         BLK   2 ; Two bytes of temporary
                                                ; storage shared by the API
                                                ; functions
export USBFS_APIEPNumber, _USBFS_APIEPNumber
_USBFS_APIEPNumber:
 USBFS_APIEPNumber:                    BLK   1 ; API storage for speed
export USBFS_APICount, _USBFS_APICount
_USBFS_APICount:
 USBFS_APICount:                       BLK   1 ; API storage for speed

export USBFS_bActivity, _USBFS_bActivity
_USBFS_bActivity:
 USBFS_bActivity:                      BLK   1 ; Activity flag (Shared between the ISR and API)
;-----------------------------------------------
;  Constant Data Allocation
;-----------------------------------------------
AREA lit (ROM, REL)
export USBFS_USB_EP0_BIT_LOOKUP
export USBFS_USB_EPX_BIT_LOOKUP
.LITERAL
USBFS_USB_EP0_BIT_LOOKUP:  ;
    DB     01H                       ; EP0
.ENDLITERAL
.LITERAL
USBFS_USB_EPX_BIT_LOOKUP:  ;
    DB     01H                       ; EP1
    DB     02H                       ; EP2
    DB     04H                       ; EP3
    DB     08H                       ; EP4
    DB     010H                      ; EP5
    DB     020H                      ; EP6
    DB     040H                      ; EP7
    DB     080H                      ; EP8
.ENDLITERAL

AREA UserModules (ROM, REL)
.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Start
;
;  DESCRIPTION:    Starts the USB User Module
;                    Sets the device selection
;                    Set the configuration to unconfigured
;                    Enables the SIE for Address 0
;                    Enables the USB pullup (D- for low speed, D+ for full speed)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A is the desired device
;                X is the operation voltage
;
;  RETURNS:              Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_Start:
_USBFS_Start:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX >USBFS_bCurrentDevice   ; Set the IDX_PP to the right page
    push    X
    M8C_SetBank1
    mov     reg[USBFS_USB_MISC_CR], USB_MISC_ENABLE_SIE
    or      reg[OSC_CR2], 0x10             ;turn on the 48Mhz clock
    M8C_SetBank0
	and     reg[CPU_SCR1], ~0x8	          ; SLIMO set to 24Mhz
	or      reg[CPU_SCR1], 0x10

    mov     [USBFS_bCurrentDevice], A  ; The app selects the desired device

    mov     [USBFS_TransferType], USB_TRANS_STATE_IDLE   ; Transaction Idle State
    mov     [USBFS_Configuration], 0   ; Unconfigured
    mov     [USBFS_DeviceStatus], 0    ; Clears device status

    mov     [USBFS_EPXDataToggle], 0   ; Clear all EP data toggles

    mov     reg[TMP_DR0], 0            ; EP1 start address in PMA space
    mov     reg[TMP_DR1], 64           ; EP2 start address in PMA space
    mov     reg[TMP_DR2], 128          ; EP3 start address in PMA space
    mov     reg[TMP_DR3], 192          ; EP4 start address in PMA space

;    mov     X, USB_MAX_EP_NUMBER      ; Set up loop to clear all of the endpoint data items
; Flow or jump here to clear the data for the next endpoint
;.loop:
;    mov     [X + USBFS_EPXDataToggle], 0    ; Or in the toggle
;    dec     X                         ; Are we done?
;    jnz     .loop                     ; Jump to do another endpoint

 IF (USBFS_CLASS & USB_CLASS_HID)
    ; Initialize USBFS_Protocol variable to comply with HID 7.2.6 Set_Protocol Request: 
    ; "When initialized, all devices default to report protocol." 
    mov     X, 2-1                     ;number of interfaces -1 
.loop:
    mov     [X + USBFS_Protocol], 1    ; Protocol = Report
    dec     X                                ;Are we done?
    jnc     .loop                            ;Jump to do another interface
ENDIF

; Flow here to enable the SIE

    mov     reg[USBFS_ADDR], USB_ADDR_ENABLE   ; Enable Address 0
    mov     reg[USBFS_USBIO_CR0], USB_AUTO_DPDM

; Set the Operating Voltage at which the chip will run
    pop     A
	or      A, USB_CR1_ENABLE_LOCK
    M8C_SetBank1
    mov     reg[USBFS_USB_CR1], A
    M8C_SetBank0
;   TODO
    mov     reg[USBFS_EP0MODE], USB_MODE_STALL_IN_OUT   ; ACK Setup/Stall IN/OUT
    M8C_EnableIntMask USBFS_INT_REG1, (USBFS_INT_RESET_MASK | USBFS_INT_EP0_MASK)

;   Enable the pullup so we can start to rock and roll
    mov     reg[USBFS_USBIO_CR1], USB_PULLUP_ENABLE   ; Pullup D+

    RAM_EPILOGUE RAM_USE_CLASS_3
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Stop
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:   Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_Stop:
_USBFS_Stop:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page

    mov     [USBFS_bCurrentDevice], 0  ; The app selects the desired device

    mov     [USBFS_TransferType], USB_TRANS_STATE_IDLE   ; Transaction Idle State
    mov     [USBFS_Configuration], 0   ; Unconfigured
    mov     [USBFS_DeviceStatus], 0    ; Clears device status
    mov     reg[USBFS_ADDR], 0         ; Clear the addfress and Address 0

    and     reg[USBFS_USBIO_CR1], ~USB_PULLUP_ENABLE   ; Release D-
    mov     reg[USBFS_INT_REG1], 0xfc ; DISable the interrupt
    mov     reg[USBFS_INT_REG2], 0x3f ; DISable the interrupt

    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bCheckActivity
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: Nothing
;
;  RETURNS:   A is a flag that indicates bus activity
;
;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bCheckActivity:
_USBFS_bCheckActivity:
    RAM_PROLOGUE RAM_USE_CLASS_1
    M8C_SetBank1
    mov    A, reg[USBFS_USB_CR1]       ; USB Activity bit indicates activity
    and    A, USB_BUS_ACTIVITY         ; Activity?
    jz     .no_activity                ; Jump on no activity?
; Flow here on bus activity
    mov    A, 1                        ; Return true
    jmp    .done
; Jump here on no activity
.no_activity:
    mov    A, 0                        ; Return false
; Jump or flow here to clear the activity bit, then return
.done:
    and    reg[USBFS_USB_CR1], ~USB_BUS_ACTIVITY    ; Clear the activity flag
    M8C_SetBank0
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetConfiguration
;
;  DESCRIPTION:   Returns the current configuration number
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None
;
;  RETURNS:      A contains the current configuration number
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bGetConfiguration:
_USBFS_bGetConfiguration:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_Configuration
    mov     A, [USBFS_Configuration]
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetEPState
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the endpoint number
;
;  RETURNS:      A contains the endpoint state
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bGetEPState:
_USBFS_bGetEPState:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_IDX >USBFS_EndpointAPIStatus
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to enable an endpoint
    mov     X, A                       ; Endpoint number is the index
    mov     A, [X+USBFS_EndpointAPIStatus]; Get the state
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION



;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bRWUEnabled
;
;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:   None
;
;  RETURNS:     A: 1--Remote Wake Up Enabled
;                  0--Remote Wake Up Disabled
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.SECTION
 USBFS_bRWUEnabled:
_USBFS_bRWUEnabled:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_DeviceStatus
    tst     [USBFS_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    jnz     .enabled                   ; Jump if enabled
; Flow here if RWU is disabled
    mov     A, 0                       ; Return disabled
    jmp     .exit                      ; Go to the common exit
; Jump when RWU is enabled
.enabled:
    mov     A, 1                       ; Return enabled
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetEPCount
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the Endpoint Number
;
;  RETURNS:              A and X contain a WORD that indicate the values stored in the
;                Count registers of the Endpoint
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
.SECTION
 USBFS_wGetEPCount:
_USBFS_wGetEPCount:
    RAM_PROLOGUE RAM_USE_CLASS_1
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to get the endpoint count
    dec     A                          ; 20x6x EPx_CNT1 is the LSB (reverse of 24x9x)
    asl     A                          ; Multiply the index by two to get to the value
    mov     X, A                       ; Endpoint number is the index
    mov     A, reg[X+USBFS_EP1CNT1]    ; Here is the count LSB
    sub     A, 2		                     ; remove the checksum from the returned count
    push    A

    mov     A, reg[X+USBFS_EP1CNT1-1 ]   ; Here is the count MSB (one bit)
    and     A, 0x01
    mov     X, A
    pop     A
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_LoadInEP and USBFS_LoadInISOCEP
;
;  DESCRIPTION:    This function loads the specified USB endpoint with
;                  the data specified.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-8] Toggle
;     [SP-7] MSB of Count to send
;     [SP-6] LSB of Count to send
;     [SP-5] MSB of data array address
;     [SP-4] LSB of data array address
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_TYPE:        equ -1
; -2 and -3 is the return address to caller
EP_NUM:     equ -4                       ; Endpoint Number
DATA_LSB:   equ -5           ; LSB pointer of data
DATA_MSB:   equ -6           ; MSB pointer of data
CNTLEN_LSB: equ -7
CNTLEN_MSB: equ -8           ; Length of data to send
TOGGLE:     equ -9

 USBFS_LoadInISOCEP:
_USBFS_LoadInISOCEP:
    mov     A, USB_MODE_ISO_IN
    push    A
    jmp             BodyLoadIN_USBFS
 USBFS_LoadInEP:
_USBFS_LoadInEP:
    mov     A, USB_MODE_ACK_IN
    push    A
BodyLoadIN_USBFS:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3

    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUM]
    cmp     A, USB_MAX_EP_NUMBER+1     ; Range check
    jnc     .exit                      ; Bail out

    ;SET THE COUNT
    mov     A, [X+CNTLEN_MSB]          ; Get the MSB of the Count
    and     A, 0x01                    ; Mask off the count bit
    mov     [USBFS_APITemp+1], A       ; Save the count
    mov     A, [X+CNTLEN_LSB]          ; Get the LSB of the Count
    mov     [USBFS_APITemp], A         ; Save the count


        ;  Perform normal data toggle or bypass?
    push    X
    mov     A, [X+TOGGLE]
    jnz     .normalToggle

		; the endpoint ISR automatically toggles the endpoint, so to support
		; the idea of not having the toggle change we must untoggle here.
    mov     A, <USBFS_USB_EPX_BIT_LOOKUP            ; calculate the address LSB
    add     A, [X+EP_NUM]              ; Get the Endpoint number (decrease by one because of EPX_BIT lookup
	dec     A						                       ; EPX_BIT lookup rearrangement.
    mov     X, >USBFS_USB_EPX_BIT_LOOKUP            ; calculate the address MSB
    swap    A, X
	adc     A, 0
	romx
	pop     X	                            ; Restore X to obtain the endpt correctly in the next block
	push    X

;    INDEX   USBFS_USB_EPX_BIT_LOOKUP ; Get the bit mask
    xor     [USBFS_EPXDataToggle], A ; Retoggle the toggle

.normalToggle:
    mov     A, <USBFS_USB_EPX_BIT_LOOKUP            ; calculate the address LSB
    add     A, [X+EP_NUM]              ; Get the Endpoint number (decrease by one because of EPX_BIT lookup
	dec     A						                       ; EPX_BIT lookup rearrangement.
    mov     X, >USBFS_USB_EPX_BIT_LOOKUP            ; calculate the address MSB
    swap    A, X
	adc     A, 0
	romx	;   now A contains the toggle

;    INDEX   USBFS_USB_EPX_BIT_LOOKUP ; Get the bit mask
    pop     X	                         ;do before the and so the zero flag won't be corrupted.
    and     A, [USBFS_EPXDataToggle]
    jz      .toggle0

    and      [USBFS_APITemp+1], ~USB_CNT_TOGGLE  ; Set the data toggle
    jmp     .toggle_done
.toggle0:
    or     [USBFS_APITemp+1], USB_CNT_TOGGLE

.toggle_done:

    mov     X, SP
    mov     A, [X+EP_NUM]               ; Get the Endpoint number
    dec     A                          ; 20x6x EPx_CNT1 is the LSB (reverse of 24x9x) [CNT1-1] is MSB
    asl     A                           ; Double the ep number for proper cnt access
    mov     X, A                        ; Make it into an index
    mov     A, [USBFS_APITemp]          ; Retrieve the saved LSB
    mov     reg[X+USBFS_EP1CNT1], A     ; Write it into the register
    mov     A, [USBFS_APITemp+1]        ; Retrieve the saved MSB
    mov     reg[X+USBFS_EP1CNT1 -1 ], A     ; Write it into the register

; It's Time to move the data

; First we need to determine where within the PMA the EP Start Address is
    mov     X, SP                       ; Get the Stack Pointer
    mov     A, [X+EP_NUM]               ; Get the Endpoint number
    mov     X, A                        ; Use the EP number as an index

   M8C_SetBank1
	;; perform the following if the EndPt is greater than 4 (which means a 20x66 family)
	cmp     A, 5                          ; if EndPt is 4 or less the Carry flag will be set
	jc     .selectPMA_PG_0                ; PMA0_WA will write to PMA page 0

;; Index from PMA8 if Endpt if 5 or more since PMA regs are non contiguous between ep4 and ep5.
;; but there dedicated pma regs for endpts 5-8 are pma regs 9 - 12.
   mov   A, reg[X+TMP_DR0-1-4]          ; Get the address of ep from tmp register
                                       ; Note the "-4" fixes the pointer to the correct EP default value
                                       ; There are only 4 tmp registers with mirrored data on PMA pg0 and pg1
                                       ; but the x index can go to 8 so it must be corrected back to x <= 4
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE1
   M8C_DisableGInt
   mov   reg[PMA8_WA], A                ; Set the Write pointer of our pma to ep space
   M8C_EnableGInt
   jmp   .PMA_selection_exit
.DontTouchGIE1:
   mov   reg[PMA8_WA], A                ; Set the Write pointer of our pma to ep space
   jmp  .PMA_selection_exit

.selectPMA_PG_0:
   mov   A, reg[X+TMP_DR0-1]            ; Get the address of ep from tmp register
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE2
   M8C_DisableGInt
   mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
   M8C_EnableGInt
   jmp   .PMA_selection_exit
.DontTouchGIE2:
   mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
.PMA_selection_exit:
	M8C_SetBank0

; Now we are ready to start moving data
    mov     X, SP
    and     [X+CNTLEN_MSB], 0x01        ; Mask off the MSB bit
    jnz     .start_send                 ; If it is high then we have 256 bytes
    mov     A, [X+CNTLEN_LSB]           ; Check the LSB register
    jz      .done                       ; If it is 0 then we have a 0 length packet
.start_send:
    mov     A, [X+DATA_LSB]
    push    A

;; determine which set of Endpts is in use.  If Epts 1-4 then use PMA regs that write to PMA page 0
;; if Epts 5-8 then use PMA regs that write to PMA page 1
    mov     X, SP                       ; Get the Stack Pointer
    mov     A, [X+EP_NUM-1]             ; Get the Endpoint number (for this operation the stack is one "off"
							                                 ; because of the push to store the LSB above (below .start_send:)
	;; perform the following if the EndPt is greater than 4 (which means a 20x66 family)
	cmp     A, 5                          ; if EndPt is 4 or less the Carry flag will be set
	jc     .selectPMA_0                   ; PMA0_WA will write to PMA page 0

IF SYSTEM_LARGE_MEMORY_MODEL
    mov     A, [X+DATA_MSB-1]           ; Get the Endpoint number (for this operation the stack is one "off"
							                                 ; because of the push to store the LSB above (below .start_send:)
    mov     reg[IDX_PP], A
ENDIF
    pop     X

.loop_ep5_8:
    mov     A, [X]
    mov     reg[PMA8_DR], A
    inc     X
    dec     [USBFS_APITemp]
    jnz     .loop_ep5_8
    jmp     .done_data_load_loop

.selectPMA_0:
IF SYSTEM_LARGE_MEMORY_MODEL
    mov     A, [X+DATA_MSB-1]           ; Get the Endpoint number (for this operation the stack is one "off"
							                                 ; because of the push to store the LSB above (below .start_send:)
    mov     reg[IDX_PP], A
ENDIF
    pop     X

.loop_ep1_4:
    mov     A, [X]
    mov     reg[PMA0_DR], A
    inc     X
    dec     [USBFS_APITemp]
    jnz     .loop_ep1_4

.done_data_load_loop:
    RAM_SETPAGE_IDX2STK
.done:
    mov     X, SP
    mov     A, [X+EP_NUM]
    mov     X, A

   M8C_SetBank1
	;; perform the following if the EndPt is greater than 4 (which means a 20x66 family)
	cmp     A, 5                          ; if EndPt is 4 or less the Carry flag will be set
	jc     .notUpperEPTS

   ;; Index from PMA8 if Endpt if 5 or more since PMA regs are non contiguous between ep4 and ep5.
	;; but there dedicated pma regs for endpts 5-8 are pma regs 9 - 12.
   mov   A, reg[X+TMP_DR0-1-4]         ; Get the value of the PMA start Address
	                                      ; Note the "-4" fixes the pointer to the correct EP default value
	                                      ; There are only 4 tmp registers with mirrored data on PMA pg0 and pg1
	                                      ; but the x index can go to 8 so it must be corrected back to x <= 4
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE3
   M8C_DisableGInt
   mov   reg[X + PMA8_RA-4], A         ; Load it into EP PMA so pre-fetch occurs
	                                      ; Note the "-4" fixes the pointer to the correct EP default reg
   M8C_EnableGInt
   jmp   .reg_adj_exit
.DontTouchGIE3:
   mov   reg[X + PMA8_RA-4], A         ; Load it into EP PMA so pre-fetch occurs
	                                      ; Note the "-4" fixes the pointer to the correct EP default reg
   jmp   .reg_adj_exit

.notUpperEPTS:
   mov   A, reg[X+TMP_DR0-1]           ; Get the value of the PMA start Address
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE4
   M8C_DisableGInt
   mov   reg[X + PMA0_RA], A           ; Load it into EP PMA so pre-fetch occurs
   M8C_EnableGInt
   jmp   .reg_adj_exit
.DontTouchGIE4:
   mov   reg[X + PMA0_RA], A           ; Load it into EP PMA so pre-fetch occurs
.reg_adj_exit:
	M8C_SetBank0

    push    X
    mov     X, SP
    mov     A, [X+EP_TYPE-1]
    pop     X

    ; Check that we aren't halted
    RAM_SETPAGE_IDX >USBFS_EndpointAPIStatus
    cmp     [X + USBFS_EndpointAPIStatus], NO_EVENT_ALLOWED    ; Get the state
    jz      .no_exempt_exit

    mov     [X + USBFS_EndpointAPIStatus], NO_EVENT_PENDING   ; Set the state

    M8C_SetBank1
    mov     reg[X + USBFS_EP1MODE-1], A ; Enable the endpoint
.no_exempt_exit:

    M8C_SetBank0

.exit:
    pop     A                          ; Clean up EP_TYPE
    RAM_EPILOGUE RAM_USE_CLASS_3
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_EnableOutEP and
;                                 USBFS_EnableOutISOCEP
;
;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the endpoint number
;
;  RETURNS:        None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
USBFS_EnableOutISOCEP:
_USBFS_EnableOutISOCEP:
    mov     X, USB_MODE_ISO_OUT
    push    X
    jmp     BodyEnableOut_USBFS
 USBFS_EnableOutEP:
_USBFS_EnableOutEP:
    mov     X, USB_MODE_ACK_OUT
    push    X
BodyEnableOut_USBFS:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_IDX >USBFS_EndpointAPIStatus

    cmp     A, 0                       ; Can't enable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .exit                      ; Bail out
; Flow here to enable an endpoint
    mov     X, A                       ; Endpoint number is the index

    ; Check that we aren't halted
    cmp     [X + USBFS_EndpointAPIStatus], NO_EVENT_ALLOWED    
    jz      .exit

    push    X
    mov     [X+USBFS_EndpointAPIStatus], NO_EVENT_PENDING   ; For the API
    mov     A, X
    asl     A
    mov     X, A
    mov     reg[X+EP1_CNT1-2], 64

	;; perform the following if the EndPt is greater than 4 (which means a 20x66 family)
    pop     A
	push    A  	                          ; recover AND preserve the Endpt number
    cmp     A, 5                       ; if EndPt is 4 or less the Carry flag will be set
	jc     .not20x66
	;; Index from PMA8 if Endpt if 5 or more since PMA regs are non contiguous between ep4 and ep5.
	;; but there dedicated pma regs for endpts 5-8 are pma regs 8 - 15.
    M8C_SetBank1
    pop     X
    mov     A, reg[X+TMP_DR0-1-4]
    mov     reg[X+PMA8_WA-4], A
	                                      ; Note the "-4" fixes the pointer to the correct EP default value
	                                      ; There are only 4 tmp registers with mirrored data on PMA pg0 and pg1
	                                      ; but the x index can go to 8 so it must be corrected back to x <= 4
	jmp .reg_adj_exit
.not20x66:



    M8C_SetBank1
    pop     X
    mov     A, reg[X+TMP_DR0-1]
    mov     reg[X+PMA0_WA], A
.reg_adj_exit:
    mov     A, reg[X+USBFS_EP1MODE-1]  ; Unlock the mode register
    pop     A

    mov     reg[X+USBFS_EP1MODE-1], A  ; Enable the endpoint
    M8C_SetBank0
    jmp         .DoneEnableOut
; Jump or flow here for a common exit
.exit:
    pop     A
.DoneEnableOut:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_DisableEP
;
;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A the endpoint number
;
;  RETURNS:               none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
.SECTION
 USBFS_DisableOutEP:
_USBFS_DisableOutEP:
    cmp     A, 0                       ; Can't disable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .exit                      ; Bail out
; Flow here to disable an endpoint
    mov     X, A                       ; Endpoint number is the index
    M8C_SetBank1
    mov     A, reg[X+USBFS_EP1MODE-1]  ; Unlock the mode register
    mov     reg[X+USBFS_EP1MODE-1], USB_MODE_NAK_OUT   ; Disable the endpoint
    M8C_SetBank0
; Jump or flow here for a common exit
.exit:
    ret                                ; All done
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Force
;
;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A: USB_FORCE_J
;                    USB_FORCE_K
;                    USB_FORCE_SE0
;                    USB_FORCE_NONE
;
;  RETURNS:       Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_Force:
_USBFS_Force:
    mov    reg[USBFS_USBIO_CR0], A
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bReadOutEP
;
;  DESCRIPTION:    This function reads the data from the USB Out endpoint
;                  and loads it into the specified buffer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-7] MSB of Count to read
;     [SP-6] LSB of Count to read
;     [SP-5] MSB of data array address to put data in
;     [SP-4] LSB of data array address to put data in
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_NUMR:     equ -3                       ; Endpoint Number
DATA_LSBR:   equ -4           ; MSB pointer of data
DATA_MSBR:   equ -5           ; LSB pointer of data
CNTLEN_LSBR: equ -6           ; Length of data to send
CNTLEN_MSBR: equ -7

 USBFS_bReadOutEP:
_USBFS_bReadOutEP:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUMR]
    cmp     A, USB_MAX_EP_NUMBER+1     ; Range check
    jnc     .exit                      ; Bail out

    ;Get the count value passed
    mov     A, [X+CNTLEN_MSBR]         ; Get the MSB of the Count
    and     A, 0x01                    ; Mask off the count bit
    mov     [USBFS_APITemp], A         ; Save the count
    mov     A, [X+CNTLEN_LSBR]         ; Get the LSB of the Count
    mov     [USBFS_APITemp+1], A       ; Save the count

    ;Determine which is smaller the requested data or the available data
    mov     A, [X+EP_NUMR]              ; Get the Endpoint number
    dec     A                          ; 20x6x EPx_CNT1 is the LSB (reverse of 24x9x) [CNT1-1] is MSB
    asl     A                           ; Double the ep number for proper cnt access
    mov     X, A                        ; Make it into an index
    mov     A, reg[X+USBFS_EP1CNT1-1]     ; Get the Real count MSB
    and     A, 0x01                     ; Mask off the LSB
    cmp     A, [USBFS_APITemp]          ; Are they equal
    jz      .MSBEqual                   ; If they are check if they are 1
    jc      .CountDetermined            ;If the requested count is smaller use it
    mov     [USBFS_APITemp], A          ; Else use the actual
    mov     A, reg[X+USBFS_EP1CNT1 ]    ; Get the Real count LSB
    mov     [USBFS_APITemp + 1], A      ; Else use the actual
    jmp     .CountDetermined
.MSBEqual:
    mov     A, [USBFS_APITemp]
    jz      .CheckLSB
    mov     [USBFS_APITemp + 1], 0
    jmp         .CountDetermined
.CheckLSB:
    mov     A, reg[X+USBFS_EP1CNT1 ]    ; Get the Real count LSB
    cmp     A, [USBFS_APITemp+1]        ; Are they equal
    jz      .CountDetermined            ; If they are check if they are 1
    jnc      .CountDetermined           ;If the requested count is smaller use it
    mov     [USBFS_APITemp+1], A        ; Else use the actual
.CountDetermined:

; First we need to determine where within the PMA the EP Start Address is
    mov     X, SP                       ; Get the Stack Pointer
    mov     A, [X+EP_NUMR]              ; Get the Endpoint number
    mov     X, A                        ; Use the EP number as an index

   M8C_SetBank1
	;; perform the following if the EndPt is greater than 4 (which means a 20x66 family)
   cmp     A, 5                        ; if EndPt is 4 or less the Carry flag will be set
	jc     .notEP5_8

   ;; Index from PMA8 if Endpt if 5 or more since PMA regs are non contiguous between ep4 and ep5.
   ;; but there dedicated pma regs for endpts 5-8 are pma regs 8 - 15.
   mov   A, reg[X+TMP_DR0-1-4]          ; Get the address of ep from tmp register
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE5
   M8C_DisableGInt
   mov   reg[PMA8_RA], A                ; Set the Read pointer of our PMA PAGE 1
   M8C_EnableGInt
   jmp   .endPMA_BankSelect
.DontTouchGIE5:
   mov   reg[PMA8_RA], A                ; Set the Read pointer of our PMA PAGE 1
   jmp   .endPMA_BankSelect

.notEP5_8:
   mov   A, reg[X+TMP_DR0-1]            ; Get the address of ep from tmp register
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE6
   M8C_DisableGInt
   mov   reg[PMA0_RA], A                ; Set the Read pointer of our PMA PAGE 0
   M8C_EnableGInt
   jmp   .endPMA_BankSelect
.DontTouchGIE6:
   mov   reg[PMA0_RA], A                ; Set the Read pointer of our PMA PAGE 0
.endPMA_BankSelect:
	M8C_SetBank0

; Now we are ready to start moving data
    and     [USBFS_APITemp], 0x01       ; Mask off the MSB bit
    jnz     .start_send                 ; If it is high then we have 256 bytes
    mov     A, [USBFS_APITemp+1]        ; Check the LSB register
    jz      .done                       ; If it is 0 then we have a 0 length packet

.start_send:

;; determine which set of Endpts is in use.  If Epts 1-4 then use PMA regs that write to PMA page 0
;; if Epts 5-8 then use PMA regs that write to PMA page 1
    mov     X, SP                       ; Get the Stack Pointer
    mov     A, [X+EP_NUMR]              ; Get the Endpoint number
	;; perform the following if the EndPt is greater than 4 (which means a 20x66 family)
	cmp     A, 5                          ; if EndPt is 4 or less the Carry flag will be set
	jc     .select_EP_PMA_PG_0            ; PMA0_WA will write to PMA page 0

    ;;
	;; procedure for PMA PG 1
	;;
    mov     X, SP
    mov     A, [X+DATA_LSBR]            ; Get the LSB of the pointer
    push    A                           ; save on stack
IF SYSTEM_LARGE_MEMORY_MODEL
    mov     A, [X+DATA_MSBR]            ; Get the MSB of the pointer
    mov     reg[IDX_PP], A              ; Use as value for IDX_PP
ENDIF
    pop     X                           ; Get the LSB again

        ;;
        ;; 24Mhz read PMA workaround (kvn)
        ;;
    M8C_SetBank1
    mov     A, reg[OSC_CR0]
    push    A
    and     A, 0xf8 ;clear the clock bits (briefly chg the cpu_clk to 3Mhz)
    or      A, 0x02 ;will set clk to 12Mhz
    mov     reg[OSC_CR0], A ;clk is now set at 12Mhz
    M8C_SetBank0

.loopPMAPG_1:
    mov     A, reg[PMA8_DR]             ; Get the data from the PMA space
    mov    [X], A                       ; save it in data array
    inc     X                           ; increment the pointer
    dec     [USBFS_APITemp+1]           ; decrement the counter
    jnz     .loopPMAPG_1                ; wait for count to zero out

    jmp     .Exit_data_extract_loop

.select_EP_PMA_PG_0:

    mov     X, SP
    mov     A, [X+DATA_LSBR]            ; Get the LSB of the pointer
    push    A                           ; save on stack
IF SYSTEM_LARGE_MEMORY_MODEL
    mov     A, [X+DATA_MSBR]            ; Get the MSB of the pointer
    mov     reg[IDX_PP], A              ; Use as value for IDX_PP
ENDIF
    pop     X                           ; Get the LSB again

        ;;
        ;; 24Mhz read PMA workaround (kvn)
        ;;
    M8C_SetBank1
    mov     A, reg[OSC_CR0]
    push    A
    and     A, 0xf8 ;clear the clock bits (briefly chg the cpu_clk to 3Mhz)
    or      A, 0x02 ;will set clk to 12Mhz
    mov     reg[OSC_CR0], A ;clk is now set at 12Mhz
    M8C_SetBank0

.loopPMAPG_0:
    mov     A, reg[PMA0_DR]             ; Get the data from the PMA space
    mov    [X], A                       ; save it in data array
    inc     X                           ; increment the pointer
    dec     [USBFS_APITemp+1]           ; decrement the counter
    jnz     .loopPMAPG_0                ; wait for count to zero out

.Exit_data_extract_loop:
        ;;
        ;; 24Mhz read PMA workaround (back to previous clock speed (kvn)
        ;;
    pop     A ;recover previous reg[OSC_CR0] value
    M8C_SetBank1
    mov     reg[OSC_CR0], A ;clk is now set at previous value (probably 24Mhz)
    M8C_SetBank0
        ;;
        ;; end 24Mhz read PMA workaround (kvn)
        ;;

    RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUMR]
    dec     A                          ; 20x6x EPx_CNT1 is the LSB (reverse of 24x9x) [CNT1-1] is MSB
    asl     A
    mov     X, A
    mov     A, reg[X+USBFS_EP1CNT1 ]    ; Get the Real count LSB
    sub     A, 2
.done:
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetEPAckState
;
;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
;                 an endpoint
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A is the Endpoint Number
;
;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bGetEPAckState:
_USBFS_bGetEPAckState:
    mov    X, A
    M8C_SetBank1
    mov    A, reg[X + USBFS_EP1MODE-1]
    M8C_SetBank0
    and    A, 0x10
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_SetPowerStatus
;
;  DESCRIPTION:    Set The Current Power status.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the power status
;
;  RETURNS:        None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_SetPowerStatus:
_USBFS_SetPowerStatus:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_DeviceStatus
    cmp     A, 0
    jz      .bus_powered
    or      [USBFS_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
    jmp     .done
.bus_powered:
    and     [USBFS_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
.done:
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret                                ; All done
.ENDSECTION
